#include "opHot_circle.h"
/*
 * opHot_circle.c
 *
 *  Created on: 2024年3月21日
 *      Author: 97329
 */
#include "opHot_circle.h"

CIRCLE_STATE_enum CIRCLE_STATE = CIRCLE_NONE;

void Circle_Check(void)
{
    // 配置预瞄点
    State_AimJudge();

    switch (CIRCLE_STATE)
    {
    case CIRCLE_LEFT_BEGIN:
        // 跟踪边线选择 优先右线
        if (Image_RightLine_Lost == 0)
            TRACE_TYPE = TRACE_RIGHT_MIDLINE;
        else if (Image_LeftLine_Lost == 0)
            TRACE_TYPE = TRACE_LEFT_MIDLINE;
        else
            TRACE_TYPE = TRACE_NONE;
        // 如果检测到第二个角点，切换到十字
        if (Image_LptLeft_Found == true && Image_LptRight_Found == true)
        {
            CIRCLE_STATE = CIRCLE_NONE;
            OVERALL_STATE = CROSS;
            CROSS_STATE = CROSS_ENTER;
        }
        // 如果角点接近或者角点消失，切换到CIRCLE_IN
        if (Image_rptsRights[Image_LptLeft_rptsLefts_id][1] >= CIRCLE_BEGIN_CORNER_EDGE_DIST || (Image_LptLeft_Found == false && Image_LptRight_Found == false))
        {
            // 启动编码器积分
            Encoder_Begin(ENCODER_MOTOR_2);

            CIRCLE_STATE = CIRCLE_LEFT_IN;
        }
        break;

    case CIRCLE_LEFT_IN:
        // 跟踪边线选择 优先左线
        Tracing_LeftFirst(TRACE_NONE);
        // 如果检测到第二个角点，切换到十字
        if (Image_LptLeft_Found == true && Image_LptRight_Found == true)
        {
            CIRCLE_STATE = CIRCLE_NONE;
            OVERALL_STATE = CROSS;
            CROSS_STATE = CROSS_ENTER;
        }
        // 编码器积分超过阈值，切换到CIRCLE_RUNNING
        if (Encoder_sum_Motor2 >= CIRCLE_IN_ENCODER_THRE)
        {
            // 重置编码器积分
            Encoder_Clear(ENCODER_MOTOR_2);
            // 开始陀螺仪积分
            Gyroscope_Begin(GYROSCOPE_GYRO_Z);

            CIRCLE_STATE = CIRCLE_LEFT_RUNNING;
        }
        break;

    case CIRCLE_LEFT_RUNNING:
        // 跟踪边线选择 优先左线
        Tracing_LeftFirst(TRACE_NONE);
        // 陀螺仪积分超过阈值或编码器积分超过阈值，切换到CIRCLE_OUT1
        if (Gyro_z >= CIRCLE_RUNNING_GYRO_THRE || Encoder_sum_Motor2 >= CIRCLE_RUNNING_ENCODER_THRE)
        {
            Encoder_Clear(ENCODER_MOTOR_2);
            //结束编码器积分
            Gyroscope_Clear(GYROSCOPE_GYRO_Z);
            Gyroscope_End(GYROSCOPE_GYRO_Z);

            CIRCLE_STATE = CIRCLE_LEFT_OUT;
        }
        break;

    case CIRCLE_LEFT_OUT:
        // 跟踪边线选择 只巡右线
        Tracing_RightOnly(TRACE_NONE);
        break;
        // 编码器积分超过阈值，结束CIRCLE状态
        if (Encoder_sum_Motor2 >= CIRCLE_OUT2_ENCODER_THRE)
        {
            Encoder_End(ENCODER_MOTOR_2);
            Encoder_Clear(ENCODER_MOTOR_2);

            CIRCLE_STATE = CIRCLE_NONE;
            OVERALL_STATE = COMMON_ROAD;
        }
        break;

    default:
        break;
    }
}